<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WaddleBot Ticker</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: transparent;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
            width: 100vw;
            height: 100vh;
        }
        
        .ticker-container {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            height: 60px;
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(10px);
            display: flex;
            align-items: center;
            overflow: hidden;
            z-index: 1000;
            transform: translateY(100%);
            transition: transform 0.3s ease-in-out;
        }
        
        .ticker-container.show {
            transform: translateY(0);
        }
        
        .ticker-content {
            white-space: nowrap;
            color: #ffffff;
            font-size: 24px;
            font-weight: 500;
            padding: 0 20px;
            display: flex;
            align-items: center;
            animation: scroll-left 15s linear infinite;
        }
        
        .ticker-icon {
            margin-right: 10px;
            font-size: 20px;
        }
        
        @keyframes scroll-left {
            0% {
                transform: translateX(100vw);
            }
            100% {
                transform: translateX(-100%);
            }
        }
        
        .ticker-urgent {
            background: rgba(220, 53, 69, 0.9);
            animation: pulse 2s infinite;
        }
        
        .ticker-info {
            background: rgba(23, 162, 184, 0.9);
        }
        
        .ticker-success {
            background: rgba(40, 167, 69, 0.9);
        }
        
        .ticker-warning {
            background: rgba(255, 193, 7, 0.9);
            color: #000;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }
        
        .ticker-queue {
            position: fixed;
            top: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.5);
            color: #fff;
            padding: 5px 10px;
            border-radius: 15px;
            font-size: 12px;
            opacity: 0;
            transition: opacity 0.3s ease;
        }
        
        .ticker-queue.show {
            opacity: 1;
        }
    </style>
</head>
<body>
    <div class="ticker-container" id="ticker">
        <div class="ticker-content" id="tickerContent">
            <span class="ticker-icon">📢</span>
            <span id="tickerText">Waiting for messages...</span>
        </div>
    </div>
    
    <div class="ticker-queue" id="queueIndicator">
        Queue: <span id="queueCount">0</span>
    </div>
    
    <script>
        class TickerManager {
            constructor() {
                this.ws = null;
                this.tickerElement = document.getElementById('ticker');
                this.contentElement = document.getElementById('tickerContent');
                this.textElement = document.getElementById('tickerText');
                this.iconElement = document.querySelector('.ticker-icon');
                this.queueElement = document.getElementById('queueIndicator');
                this.queueCountElement = document.getElementById('queueCount');
                
                this.currentMessage = null;
                this.messageQueue = [];
                this.isDisplaying = false;
                this.hideTimeout = null;
                
                this.connectWebSocket();
                this.startHeartbeat();
            }
            
            connectWebSocket() {
                try {
                    this.ws = new WebSocket('[[=ws_url]]');
                    
                    this.ws.onopen = () => {
                        console.log('WebSocket connected');
                        this.sendAnalytics('connection', 'connected');
                    };
                    
                    this.ws.onmessage = (event) => {
                        try {
                            const data = JSON.parse(event.data);
                            this.handleMessage(data);
                        } catch (error) {
                            console.error('Failed to parse message:', error);
                        }
                    };
                    
                    this.ws.onclose = () => {
                        console.log('WebSocket closed, attempting to reconnect...');
                        setTimeout(() => this.connectWebSocket(), 5000);
                    };
                    
                    this.ws.onerror = (error) => {
                        console.error('WebSocket error:', error);
                        this.sendAnalytics('error', 'websocket_error');
                    };
                    
                } catch (error) {
                    console.error('Failed to connect WebSocket:', error);
                    setTimeout(() => this.connectWebSocket(), 5000);
                }
            }
            
            handleMessage(data) {
                switch (data.type) {
                    case 'connected':
                        console.log('Connected to community:', data.community_id);
                        break;
                        
                    case 'ticker':
                        this.queueMessage(data);
                        break;
                        
                    case 'pong':
                        // Heartbeat response
                        break;
                        
                    default:
                        console.log('Unknown message type:', data.type);
                }
            }
            
            queueMessage(data) {
                const message = {
                    text: data.text || 'No message',
                    duration: (data.duration || 10) * 1000,
                    style: data.style || 'default',
                    priority: data.priority || 5,
                    timestamp: new Date().toISOString()
                };
                
                // Insert message based on priority
                let inserted = false;
                for (let i = 0; i < this.messageQueue.length; i++) {
                    if (message.priority < this.messageQueue[i].priority) {
                        this.messageQueue.splice(i, 0, message);
                        inserted = true;
                        break;
                    }
                }
                
                if (!inserted) {
                    this.messageQueue.push(message);
                }
                
                this.updateQueueIndicator();
                
                // Start processing if not already displaying
                if (!this.isDisplaying) {
                    this.processQueue();
                }
            }
            
            processQueue() {
                if (this.messageQueue.length === 0) {
                    this.isDisplaying = false;
                    this.hideTickerDelayed();
                    return;
                }
                
                this.isDisplaying = true;
                const message = this.messageQueue.shift();
                this.updateQueueIndicator();
                
                this.displayMessage(message);
                
                // Schedule next message
                setTimeout(() => {
                    this.processQueue();
                }, message.duration);
            }
            
            displayMessage(message) {
                // Clear any existing timeout
                if (this.hideTimeout) {
                    clearTimeout(this.hideTimeout);
                    this.hideTimeout = null;
                }
                
                // Set message content
                this.textElement.textContent = message.text;
                
                // Apply style
                this.tickerElement.className = `ticker-container show ticker-${message.style}`;
                
                // Set icon based on style
                const icons = {
                    'urgent': '🚨',
                    'info': 'ℹ️',
                    'success': '✅',
                    'warning': '⚠️',
                    'default': '📢'
                };
                
                this.iconElement.textContent = icons[message.style] || icons.default;
                
                // Calculate scroll speed based on text length
                const textLength = message.text.length;
                const baseSpeed = 15; // seconds
                const adjustedSpeed = Math.max(baseSpeed, textLength * 0.1);
                
                this.contentElement.style.animationDuration = `${adjustedSpeed}s`;
                
                // Analytics
                this.sendAnalytics('display', 'message_shown', {
                    style: message.style,
                    length: textLength,
                    duration: message.duration
                });
            }
            
            hideTickerDelayed() {
                this.hideTimeout = setTimeout(() => {
                    this.tickerElement.classList.remove('show');
                }, 2000);
            }
            
            updateQueueIndicator() {
                this.queueCountElement.textContent = this.messageQueue.length;
                
                if (this.messageQueue.length > 0) {
                    this.queueElement.classList.add('show');
                } else {
                    this.queueElement.classList.remove('show');
                }
            }
            
            sendAnalytics(eventType, action, data = {}) {
                if (this.ws && this.ws.readyState === WebSocket.OPEN) {
                    this.ws.send(JSON.stringify({
                        type: 'analytics',
                        event_type: eventType,
                        event_data: {
                            action: action,
                            timestamp: new Date().toISOString(),
                            user_agent: navigator.userAgent,
                            ...data
                        }
                    }));
                }
            }
            
            startHeartbeat() {
                setInterval(() => {
                    if (this.ws && this.ws.readyState === WebSocket.OPEN) {
                        this.ws.send(JSON.stringify({
                            type: 'ping',
                            timestamp: new Date().toISOString()
                        }));
                    }
                }, 30000); // Every 30 seconds
            }
        }
        
        // Initialize ticker manager when page loads
        document.addEventListener('DOMContentLoaded', () => {
            new TickerManager();
        });
        
        // Handle page visibility changes
        document.addEventListener('visibilitychange', () => {
            if (document.hidden) {
                // Page is hidden, reduce activity
            } else {
                // Page is visible, resume normal activity
            }
        });
    </script>
</body>
</html>